/* Medama Cherenkov Maker * Copyright (C) 2010 anekos <anekos616@gmail.com( * * GIMP - The GNU Image Manipulation Program * Copyright (C) 1995 Spencer Kimball and Peter Mattis * * Supernova plug-in * Copyright (C) 1997 Eiichi Takamori <taka@ma1.seikyou.ne.jp>, *                    Spencer Kimball, Federico Mena Quintero * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */-->function gauss () {  var sum = 0.0;  for (var i = 0; i < 6; i++)    sum += Math.random();  return sum / 6.0;}function rangeRand (from, to) {  var d = to - from;  return Math.random(d) + from;}function rgb2hsv (r, g, b) {  var v = Math.max(Math.max(r, g), b);  var min = Math.min(Math.min(r, g), b);  if (v == 0)    return {h: 0, s: 0, v: 0};  var d = v - min;  var s = d / v;  var rr = (v - r) / d;  var gg = (v - g) / d;  var bb = (v - b) / d;  var h = v == r ? bb - gg :          v == g ? 2 + rr - bb :                   4 + gg - rr;  if (h < 0)    h += 1;  return {h: h / 6, s: s, v: v};}var hsv2rgb = (function () {  var hrtbl = [    [0, 3, 1],    [2, 0, 1],    [1, 0, 3],    [1, 2, 0],    [3, 1, 0],    [0, 1, 2]  ];  return function (h, s, v) {    if (s == 0)      return [v, v, v];    h *= 6;    var i = Math.floor(h);    var f = h - i;    var rs = [v, v * (1 - s), v * (1 - s * f), v * (1 - s * (1 - f))];    var idx = hrtbl[i];    return [rs[idx[0]], rs[idx[1]], rs[idx[2]]];  };})();function clamp (v, from, to) {  return v < from ? from :         v > to   ? to :         v;}function time (name, func, args, _this) {  var a = new Date();  var r = args ? func.apply(_this, args) : func();  var b = new Date();  return [(b.getTime() - a.getTime()) / 1000, r];}function logTime (name, func, args, _this) {  var rt = time.apply(null, arguments);  if (console && typeof console.log === 'function')    console.log(name + ": " + rt[0] + "msec");  return rt;}/**************************************************************************/function nova (context, opt) {  var width = opt.width, height = opt.height;  var xc = opt.xcenter, yc = opt.ycenter;  var x1 = 0, y1 = 0, x2 = width, y2 = height;  var imgData = context.getImageData(0, 0, width, height);  var pixels = imgData.data;  var spoke = [];  var spokecolor = [];  var hsv = rgb2hsv.apply(null, opt.color);  for (var i = 0; i < opt.nspoke; i++) {    spoke.push(gauss());    hsv.h += opt.randomhue /              360.0 * rangeRand(-0.5, 0.5);    if (hsv.h < 0)      hsv.h += 1.0;    else if (hsv.h >= 1.0)      hsv.h -= 1.0;    spokecolor.push(hsv2rgb(hsv.h, hsv.s, hsv.v));  }  for (var row = 0, y = 0; row < y2; row++, y++) {    for (var col = 0, x = 0; col < x2; col++, x++) {      var u = (x - xc) / opt.radius;      var v = (y - yc) / opt.radius;      var l = Math.sqrt(u * u + v * v);      var t = (Math.atan2(u, v) / (2 * Math.PI) + 0.51) * opt.nspoke;      var i = Math.floor(t);      t -= i;      i %= opt.nspoke;      var w1 = spoke[i] * (1 - t) + spoke[(i + 1) % opt.nspoke] * t;      w1 = w1 * w1;      var w = 1 / (l + 0.001) * 0.9;      var nova_alpha = clamp(w, 0.0, 1.0);      var ratio = nova_alpha;      var compl_ratio = 1.0 - ratio;      var ptr = (y * width + x) * 4;      for (var ci = 0; ci < 3; ci++ ) {        var srccol = pixels[ptr + ci] / 255;        var spokecol = spokecolor[i][ci] * (1.0 - t) + spokecolor[(i + 1) % opt.nspoke][ci] * t;        var outcol = w > 1.0 ? clamp(spokecol * w, 0.0, 1.0) :                               srccol * compl_ratio + spokecol * ratio;        var c = clamp(w1 * w, 0.0, 1.0);        outcol += c;        outcol *= 255;        pixels[ptr + ci] = clamp(parseInt(outcol, 10), 0, 255);      }    }  }  context.putImageData(imgData, 0, 0);}function drawBaseImage () {  canvas.width = img.width;  canvas.height = img.height;  context = canvas.getContext('2d');  context.fillStyle = "rgb(255, 255, 255)";  context.fillRect (0, 0, 150, 150);  context.drawImage(img, 0, 0);}function clampedValue (id, from, to) {  return clamp(parseInt(document.getElementById(id).value, 10), from, to);}function superNova (pos) {  logTime(    'nova',    nova,    [      context,      {        width: img.width,        height: img.height,        xcenter: pos.x,        ycenter: pos.y,        color: rgbdata || [0.35, 0.39, 1.0, 1.0],        radius: clampedValue('radius', 0, 100),        nspoke: clampedValue('nspoke', 1, 100),        randomhue: clampedValue('randomhue', 0, 360),      }    ]  );}var dropbox = document.getElementById("canvas");